#include <cmath>
#include <unistd.h>
//915
#include <QApplication>
#include <QDebug>
#include <QFileDialog>
#include <QKeyEvent>
#include <QLabel>
#include <QPushButton>
#include <QRadioButton>
#include <QRegExp>
#include <QtConcurrentRun>
#include <QtCrypto>
#include <QThread>
#include <QTimer>
#include <QVBoxLayout>

#include "main.hh"

// RSA encryption of private messages
#include "crypto.cc"
#include "crypto.hh"

// Barrier-to-entry file parameters
#define BTE_PREFIX "sdfjaoew"
#define BTE_SUFFIX "qwertyqazol"
#define BTE_EXTENSION ".newdole"
#define BTE_SIZE 2621440
#define BTE_COUNT 5



Q_DECLARE_METATYPE(VotingHistory);



QString generateBTEFileName(int n) {
  return BTE_PREFIX + QString::number(n) + BTE_SUFFIX + BTE_EXTENSION;
}

// make sure this matches ALL filenames generated by generateBTEFileName(...)
QString generateBTERegexString() {
  return BTE_PREFIX + QString("\\d+") + BTE_SUFFIX + BTE_EXTENSION;
}

PrivDialog::PrivDialog(ChatDialog* dialog, QString origin, NetSocket* sock) {
  // 'Enter' detection for text entry box.
  key = new PrivKeyEnterReceiver();
  installEventFilter(key);
  key->dialog = this;

  this->origin = origin;
  this->sock = sock;
  this->cDialog = dialog;
  
  setWindowTitle(origin);

  // Read-only text box where we display messages from everyone.
  // This widget expands both horizontally and vertically.
  textview = new QTextEdit(this);
  textview->setReadOnly(true);

  // Text box where we enter messages.
  textline = new QTextEdit(this);

  // Set the keyboard focus to the text-entry box.
  textline->setFocus();

  QVBoxLayout *layout = new QVBoxLayout();
  layout->addWidget(textview);
  layout->addWidget(textline);
  setLayout(layout);
  
  // Send cryptographic keys to peer.
  const QString blank = QString("");
  QString temp = QString("");
  QVariantMap *crypto_map = sock->makeMyRumorMap(&blank, &origin, true);
  // QVariantMap *crypto_map = new QVariantMap();
  crypto_map->insert("N", QString((dialog->n).c_str()));
  crypto_map->insert("PublicKey", QString((dialog->pub_key).c_str()));
  crypto_map->insert(QString("Crypto"), "Crypto");
  
  QHash< QString, Destination*>* table = sock->routingTable;
  Destination* dest = table->value(origin);
  Peer peer;
  peer.IP = dest->IP;
  peer.port = dest->port;
  sock->sendMap(crypto_map, &peer);
}

void PrivDialog::privMsgEntered() {
  QString text = textline->toPlainText();
  // If user inputting only a newline, eliminate it.
  if (QString::compare(QString("\n"), text, Qt::CaseInsensitive) == 0)
    textline->clear();
  else if (text.length() > 0) {
    string trimmedText = text.trimmed().replace("\n", "").toUtf8().constData();

    string pub_key = this->cDialog->cryptoKeys->value(origin).first.toUtf8().constData();
    string n = this->cDialog->cryptoKeys->value(origin).second.toUtf8().constData();
    // qDebug() << "trimmed Text: " << trimmedText.c_str();
    // qDebug() << "public key: " << pub_key.c_str();
    // qDebug() << "N: " << n.c_str();

    const QString encrypted_msg = QString::fromUtf8(rsa_encrypt(trimmedText, pub_key, n).c_str());

    QVariantMap* map = sock->makeMyRumorMap(&encrypted_msg, &origin, true);
    Destination* dest = sock->routingTable->value(origin);
    Peer peer;
    peer.IP = dest->IP;
    peer.port = dest->port;
    sock->sendMap(map, &peer);

    textview->append(trimmedText.c_str());
    // Before clearing 'textline', check if its length is 0 to avoid calling
    // this function infinitely many times.
    if (text.length() != 0) {
      textline->clear();
    }
  }
}

bool PrivKeyEnterReceiver::eventFilter(QObject *obj, QEvent *event) {
  if(event->type() == QEvent::KeyRelease) {
    QKeyEvent *key = static_cast<QKeyEvent *>(event);

    if((key->key() == Qt::Key_Enter) || (key->key() == Qt::Key_Return)) {
      dialog->privMsgEntered();
    } else {
      return QObject::eventFilter(obj, event);
    }
    return true;
  } else {
    return QObject::eventFilter(obj, event);
  }

  return false;
}

VoteDialog::VoteDialog() {
  setWindowTitle("File Evaluation");
  QLabel *voteTextLabel = new QLabel("Please vote on the downloaded file.");

  QPushButton *goodFile = new QPushButton("I liked this file!");
  connect(goodFile, SIGNAL(clicked()), this, SLOT(upvoted()));

  QPushButton *badFile = new QPushButton("I didn't like this file!");
  connect(badFile, SIGNAL(clicked()), this, SLOT(downvoted()));

  QVBoxLayout *layout = new QVBoxLayout();
  layout->addWidget(voteTextLabel);
  layout->addWidget(goodFile);
  layout->addWidget(badFile);
  setLayout(layout);
}

void VoteDialog::upvoted() {
  accept();
}

void VoteDialog::downvoted() {
  reject();
}

bool ChatKeyEnterReceiver::eventFilter(QObject *obj, QEvent *event) {
  if(event->type() == QEvent::KeyRelease) {
    QKeyEvent *key = static_cast<QKeyEvent *>(event);

    if((key->key() == Qt::Key_Enter) || (key->key() == Qt::Key_Return)) {
      dialog->myMessageEntered();
    } else {
      return QObject::eventFilter(obj, event);
    }
    return true;
  } else {
    return QObject::eventFilter(obj, event);
  }

  return false;
}

ChatDialog::ChatDialog(NetSocket* sock) {
  // Generate cryptographic keys for RSA
  vector<string> key_vec = gen_keys();
  n =        key_vec[0];
  pub_key =  key_vec[1];
  priv_key = key_vec[2];

  qDebug() << "New Public Key: " << pub_key.c_str();
  qDebug() << "New Private Key: " << priv_key.c_str();
  qDebug() << "N = p * q: " << n.c_str();

  this->cryptoKeys = new QHash<QString, QPair<QString, QString> >();

  // 'Enter' detection for text entry box.
  key = new ChatKeyEnterReceiver();
  installEventFilter(key);
  key->dialog = this;
  fileMap = new FileMap();
  privMsgs = new QHash<QString, PrivDialog*>();
  this->sock = sock;
  messages = new MessageList();
  myOriginID = new QString("aefijaw");
  qsrand(QTime::currentTime().msec());
  myOriginID->append(QString::number(qrand()));

  setWindowTitle(QString::number(sock->myPort));

  // Read-only text box where we display messages from everyone.
  // This widget expands both horizontally and vertically.
  textview = new QTextEdit(this);
  textview->setReadOnly(true);

  // Text box where we enter messages.
  textline = new QTextEdit(this);
  textline->setFocus();

  QLabel *peerlineLabel = new QLabel("Host:addr of a peer:");
  peerline = new QLineEdit(this);
  connect(peerline, SIGNAL(returnPressed()), this, SLOT(hostAddrEntered()));

  QLabel *peerOriginsLabel = new QLabel("List of known origin ID's:");
  peerOrigins = new QListWidget(this);
  connect(peerOrigins, SIGNAL(itemDoubleClicked(QListWidgetItem*)), this,
          SLOT(openPrivateMsgWindow(QListWidgetItem*)));

  QLabel *searchlineLabel = new QLabel("Search for a file.");
  searchline = new QLineEdit(this);
  connect(searchline, SIGNAL(returnPressed()), this,
      SLOT(searchQueryEntered()));

  QLabel *searchResultsLabel = new QLabel("Search results");
  searchResults = new QListWidget(this);
  connect(searchResults, SIGNAL(itemDoubleClicked(QListWidgetItem*)), this,
          SLOT(sendDownloadRequest(QListWidgetItem*)));

  m_button = new QPushButton("Share File(s)", this);
  connect(m_button, SIGNAL(released()), this, SLOT(handleButton()));
  m_button->setAutoDefault(false);

  // Download-all functionality not yet implemented, so disable this button!
  btnDownload = new QPushButton("Download all files", this);
  connect(btnDownload, SIGNAL(released()), this, SLOT(downloadAllFiles()));
  btnDownload->setAutoDefault(false);
  btnDownload->setVisible(false);

  btnUnlock = new QPushButton("Unlock peerster!");
  connect(btnUnlock, SIGNAL(released()), this, SLOT(tryUnlock()));
  btnUnlock->setAutoDefault(false);

  // Lay out the widgets to appear in the main window.
  QVBoxLayout *layout = new QVBoxLayout();
  layout->addWidget(textview);
  layout->addWidget(textline);
  layout->addWidget(peerlineLabel);
  layout->addWidget(peerline);
  layout->addWidget(peerOriginsLabel);
  layout->addWidget(peerOrigins);
  layout->addWidget(m_button);
  layout->addWidget(searchlineLabel);
  layout->addWidget(searchline);
  layout->addWidget(searchResultsLabel);
  layout->addWidget(searchResults);
  layout->addWidget(btnDownload);
  layout->addWidget(btnUnlock);
  setLayout(layout);
}

void ChatDialog::sendDownloadRequest(QListWidgetItem* item) {
  sock->sendDownloadRequest(item);
}

QByteArray ChatDialog::getMetafileHashes(QVariantList fileMatches) {
  QByteArray ret = QByteArray();
  for (int i = 0; i < fileMatches.size(); ++i) {
    QString fileName = fileMatches.at(i).toString();
    if (fileMap->count(fileName) == 0) {
      qDebug() << "File map did not contain file name, was expected to.";
    }
    ret.append(fileMap->at(fileName).hash);
  }
  return ret;
}

void ChatDialog::addFile(QString fileName) {
  QFile f(fileName);
  f.open(QIODevice::ReadOnly);
  qint64 numBytes = f.bytesAvailable();

  FileData fd;
  fd.numBytes = numBytes;
  while (numBytes > 0) {
    fd.metafile.append(QCA::Hash("sha1").hash(f.read(8192)).toByteArray());
    numBytes -= 8192;
  }

  fd.hash.append(QCA::Hash("sha1").hash(fd.metafile).toByteArray());
  fileMap->erase(fileName);
  fileMap->insert(make_pair(fileName, fd));
  f.close();
}

void ChatDialog::handleButton() {
  QFileDialog dialog(this);
  dialog.setFileMode(QFileDialog::AnyFile);
  QStringList fileNames = QFileDialog::getOpenFileNames(this);
  for (QString fileName : fileNames) {
    addFile(fileName);
  }
}

void ChatDialog::downloadAllFiles() {
  qDebug() << "DOWNLOAD FILES BUTTON CLICKED :)";
  for (int i = 0; i < searchResults->count(); i++) {
    QListWidgetItem *item = searchResults->item(i);
    qDebug() << "file: " << item->text();
    sock->sendDownloadRequest(item);
  }
}

void ChatDialog::tryUnlock() {
  for (int i = 0; i < BTE_COUNT; i++) {
    QString fileName = generateBTEFileName(i);
    if (!sock->downloadedFiles->contains(fileName)) {
      qDebug() << "Not all files have been downloaded!";
      return;
    }
  }

  peerline->setEnabled(true);
  peerOrigins->setEnabled(true);
  searchline->setEnabled(true);
  m_button->setEnabled(true);
  textline->setEnabled(true);
  textview->setEnabled(true);

  btnUnlock->setVisible(false);

  sock->unlocked = true;

  searchResults->clear();

  qDebug() << "Good job!  You have unlocked Peerster :)";
}

void ChatDialog::openPrivateMsgWindow(QListWidgetItem *item) {
  // item->text() is an origin identifier.
  openPrivateMsgWindow(item->text());
}

void ChatDialog::openPrivateMsgWindow(QString text) {
  if (privMsgs->contains(text)) {
    privMsgs->value(text)->show();
  } else {
    PrivDialog* pd = new PrivDialog(this, text, sock);
    privMsgs->insert(text, pd);
    pd->show();
  }
}

void ChatDialog::hostAddrEntered() {
  if (sock->unlocked) {
    sock->addPeer(peerline->text());
    peerline->clear();
  }
}

void ChatDialog::searchQueryEntered() {
  sock->handleSearchRequest(searchline->text());
  searchline->clear();
}

void ChatDialog::myMessageEntered() {
  QString text = textline->toPlainText();
  if (text.length() > 0) {
    const QString trimmedText = text.trimmed().replace("\n", "");
    QVariantMap* map = sock->makeMyRumorMap(&trimmedText, new QString(), false);
    sock->incomingRQ.load()->push(map);
    sock->handleIncomingRQ();

    textview->append(trimmedText);
    // Before clearing 'textline', check if its length is 0 to avoid calling
    // this function infinitely many times.
    if (text.length() != 0) {
      textline->clear();
    }
  }
}

void ChatDialog::displayMsg(const QString& text, const QString& orig) {
  // Only display messages that are NOT from me. My messages are displayed
  // through another code path. This is to allow for smooth behavior when I am
  // not chatting with anyone else.
  if (orig.compare(*myOriginID) != 0) {
    textview->append(text.trimmed());
  }
}

QByteArray ChatDialog::findBlock(QByteArray blockHash) {
  for (FileMap::iterator it = fileMap->begin(); it != fileMap->end(); ++it) {
    FileData data = (FileData) it->second;
    QByteArray metafile = data.metafile;
    if (blockHash == data.hash) {
      return metafile;
    }

    if (metafile.length() % 20 != 0) {
      qDebug() << "metafile length not multiple of 20.";
    }
    int numBlocks = metafile.length() / 20;
    for (int i = 0; i < numBlocks; ++i) {
      if (match(metafile, blockHash, i)) {
        return getFileBlock(it->first, i);
      }
    }
  }
  return QByteArray();
}

QByteArray ChatDialog::getFileBlock(const QString file, int i) {
  QFile f(file);
  f.open(QIODevice::ReadOnly);
  QByteArray ret = QByteArray();
  f.read(i * 8192);
  ret.append(f.read(8192));
  f.close();
  return ret;
}

bool ChatDialog::match(QByteArray metafile, QByteArray blockHash, int i) {
  int ix20 = i * 20;
  for (int j = 0; j < 20; ++j) {
    if (metafile.at(ix20 + j) != blockHash.at(j)) {
      return false;
    }
  }
  return true;
}

void ChatDialog::addMsg(QVariantMap* map) {
  QString orig = map->value(*(sock->originKey)).toString();
  QString text;
  if(map->contains(*(sock->chatTextKey))) {
    text = map->value(*(sock->chatTextKey)).toString();
  } else {
    text = QString::null;
  }
  if (messages.load()->count(orig) == 0) {
    vector<QString> emptyMessages;
    messages.load()->insert(make_pair(orig, emptyMessages));
  }
  messages.load()->at(orig).push_back(text);
}

NetSocket::NetSocket() {
  // Initialize constants
  incomingRQ = new queue< QVariantMap*>();
  outgoingRQ = new queue< QVariantMap*>();
  currentRumorMessage = NULL;
  blockReplyKey = new QString("BlockReply");
  blockRequestKey = new QString("BlockRequest");
  budgetKey = new QString("Budget");
  chatTextKey = new QString("ChatText");
  cryptoKey = new QString("Crypto");
  dataKey = new QString("Data");
  destKey = new QString("Dest");
  hopLimitKey = new QString("HopLimit");
  matchIDsKey = new QString("MatchIDs");
  matchNamesKey = new QString("MatchNames");
  originKey = new QString("Origin");
  searchReplyKey = new QString("SearchReply");
  searchRequestKey = new QString("Search");
  seqNoKey = new QString("SeqNo");
  wantKey = new QString("Want");
  lastIPKey = new QString("LastIP");
  lastPortKey = new QString("LastPort");

  // if tagKey = 1, then that means I'm sending a routing table and I want a
  // response routing table.  If tagKey = 2, that means I'm sending a routing
  // table but don't want one in reply.
  tagKey = new QString("Tag");
  vhKey = new QString("vhKey");
  routingTable = new QHash< QString, Destination*>();
  portWaitingFor = 0;
  forwarding = true;
  searching = false;
  IPwaitingFor = QHostAddress::Null;
  hostLookups = new HNLookupList();
  hashOfRequestedBlock = QByteArray();
  blocksRemaining = -1;
  nameOfRequestedFile = "";
  resultMap = new ResultMap();
  votingHistory = new VotingHistory();
  downloadedFiles = new QSet<QString>();
  unlocked = false;

  // Pick a range of four UDP ports to try to allocate by default, computed
  // based on my Unix user ID. This makes it trivial for up to four Peerster
  // instances per user to find each other on the same host, barring UDP port
  // conflicts with other applications (which are quite possible).
  // We use the range from 32768 to 49151 for this purpose.
  myPortMin = 32768 + (getuid() % 4096) * 4;
  myPortMax = myPortMin + 3;

  // Anti Entropy
  QTimer *aeTimer = new QTimer(this);
  connect(aeTimer, SIGNAL(timeout()), this, SLOT(antiEntropy()));
  aeTimer->start(10000);

  // Route rumor
  QTimer *rrTimer = new QTimer(this);
  connect(rrTimer, SIGNAL(timeout()), this, SLOT(routeRumor()));
  rrTimer->start(60000);

  // Register a callback for whenever datagrams are received, so that their
  // message (if they are of the correct form) can be displayed in the text
  // window.
  connect(this, SIGNAL(readyRead()), this, SLOT(readMessage()));
}

void NetSocket::sendDownloadRequest(QListWidgetItem* item) {
  dialog->searchResults->setEnabled(false);

  QString fileNameScore = item->text();  // of format: Block.txt (1.0)
  QString fileName = fileNameScore.left(fileNameScore.indexOf("(")).trimmed();

  ResultData resultData = resultMap->at(fileName);
  const QString dest = resultData.uploaderDest;
  QByteArray hash = resultData.hash;
  requestingMetafile = true;
  requestingDataBlock = false;
  nameOfRequestedFile = fileName;
  sendBlockRequest(&dest, *(dialog->myOriginID), (quint32) 10, hash);
}

void NetSocket::routeRumor() {
  quint32 seqno;
  MessageList* myMessages = dialog->messages.load();
  if (myMessages->count(*(dialog->myOriginID)) == 0) {
    seqno = 1;
  } else {
    seqno = (quint32) myMessages->at(*(dialog->myOriginID)).size() + 1;
  }

  QVariantMap* map = new QVariantMap();
  map->insert(*originKey, *(dialog->myOriginID));
  map->insert(*seqNoKey, seqno);
  incomingRQ.load()->push(map);
  handleIncomingRQ();
}

// Remember, "async" defaults to true
void NetSocket::addPeer(QString arg, bool async) {
  int i = arg.indexOf(':');
  if (i <= 0 || i == arg.size() - 1) {
    qDebug() << "Specified peer needs form host:port";
    return;
  }

  QStringList list = arg.split(':');
  QString host = list.at(0);
  QString portStr = list.at(1);
  if (portStr.indexOf(':') != -1) {
    qDebug() << "Two colons detected in specified peer.  Needs form host:port.";
    return;
  }

  quint16 port = portStr.toUShort();
  
  QHostAddress address;
  // Try to parse 'host' as an IP address. If this doesn't work, then treat
  // 'host' as a hostname and look up its corresponding IP.
  if (!address.setAddress(host)) {
    if (async) {
      hostLookups.load()->insert(make_pair(host, port));
      QHostInfo::lookupHost(host, this, SLOT(lookedUpHost(QHostInfo)));
    } else {
      QHostInfo hostInfo = QHostInfo::fromName(host);
      QHostAddress addr = hostInfo.addresses().first();
      Peer *peerPtr = findOrAddPeer(addr, portStr.toInt());
      sendStatusMessage(peerPtr);

      // try to get the unlocking files from these peers
      //if (!unlocked) {
      //  QString query = generateBTERegexString();
      //  QListWidgetItem item(query);
      //  handleSearchRequest(query);
      //}
    }
  }
}

void NetSocket::lookedUpHost(const QHostInfo &host) {
  if (hostLookups.load()->count(host.hostName()) == 0) {
    qDebug() << "lookedUpHost: Host name has already been looked up.";
    return;
  }

  if (host.error() != QHostInfo::NoError) {
    qDebug() << "Lookup failed:" << host.errorString();
    return;
  }

  qDebug() << "Lookup succeeded.";

  QHostAddress addr = host.addresses().first();
  Peer *peerPtr = findOrAddPeer(addr, hostLookups.load()->at(host.hostName()));
  hostLookups.load()->erase(host.hostName());

  // rumormonger with added peer immediately to get them into the network
  sendStatusMessage(peerPtr);

  // try to get the unlocking files from these peers
  //if (!unlocked) {
  //  QString query = generateBTERegexString();
  //  QListWidgetItem item(query);
  //  handleSearchRequest(query);
  //}
}

void NetSocket::antiEntropy() {
  Peer* peer = getRandomPeer();
  sendStatusMessage(peer);
}

bool NetSocket::bind() {
  // Try to bind to each of the range myPortMin..myPortMax in turn.
  for (quint16 p = myPortMin; p <= myPortMax; p++) {
    if (QUdpSocket::bind(p)) {
      myPort = p;
      qDebug() << "bound to UDP port " << p;

      // Add in the default peers as soon as I know my port.
      for (quint16 i = 1; i < 4; ++i) {
        quint16 port = myPort + i;
        if (port > myPortMax) {
          port -= 4;
        }
        findOrAddPeer(QHostAddress::LocalHost, port);
      }

      return true;
    }
  }

  qDebug() << "Oops, no ports in my default range " << myPortMin
    << "-" << myPortMax << " available";
  return false;
}

Peer* NetSocket::findOrAddPeer(QHostAddress address, quint16 port) {
  for (Peer* peer : peers) {
    if (peer->IP == address && peer->port == port) {
      return peer;
    }
  }
  
  // Peer not found. Create new peer.
  Peer* peer = new Peer();
  peer->IP = address;
  peer->port = port;
  peers.push_back(peer);
  return peer;
}

Peer* NetSocket::getRandomPeer() {
  return peers.at(rand() % peers.size());
}

QVariantMap* NetSocket::makeMyRumorMap(const QString* text, const QString* dest,
     bool priv) {
  QVariantMap* map = new QVariantMap();
  map->insert(*chatTextKey, *text);
  map->insert(*originKey, *(dialog->myOriginID));
  if (priv) {
    map->insert(*hopLimitKey, (quint32) 10);
    map->insert(*destKey, *dest);
  } else {
    MessageList* myMessages = dialog->messages.load();
    quint32 seqno;
    if (myMessages->count(*(dialog->myOriginID)) == 0) {
      seqno = 1;
    } else {
      seqno = (quint32) myMessages->at(*(dialog->myOriginID)).size() + 1;
    }
    map->insert(*seqNoKey, seqno);
  }
  return map;
}

void NetSocket::sendMap(QVariantMap* map, Destination* dest) {
  Peer peer;
  peer.IP = dest->IP;
  peer.port = dest->port;
  sendMap(map, &peer);
}

void NetSocket::sendMap(QVariantMap *map, Peer* peer) {
  QByteArray a;
  QDataStream s(&a, QIODevice::WriteOnly);
  s << *map;
  writeDatagram(a, peer->IP, peer->port);
}

void NetSocket::sendRumor(Peer* peer, QString text, QString orig,
      quint32 seqno) {
  QVariantMap *map = new QVariantMap();
  // Route rumor messages were stored as QString::null in the message vector.
  if (!text.isNull()) {
    map->insert(*chatTextKey, text);
  }
  map->insert(*originKey, orig);
  map->insert(*seqNoKey, seqno);
  sendMap(map, peer);
}

void NetSocket::handleSearchRequest(QString text) {
  searching = true;
  searchText = text;
  dialog->searchResults->clear();
  searchBudget = (quint32) 2;
  numMatches = 0;
  resultMap = new ResultMap();
  sendSearch();
  srTimer = new QTimer(this);
  connect(srTimer, SIGNAL(timeout()), this, SLOT(sendSearch()));
  srTimer->start(1000);
}

void NetSocket::sendSearch() {
  for (Peer* peer : peers) {
    QVariantMap* map = new QVariantMap();
    map->insert(*originKey, *(dialog->myOriginID));
    map->insert(*searchRequestKey, searchText);
    if (searchBudget != (quint32) 128 && numMatches <= 10) {
      searchBudget *= 2;
      map->insert(*budgetKey, searchBudget);
      sendMap(map, peer);
    } else {
      srTimer->stop();
      searching = false;
    }
  }
}

void NetSocket::sendSearchReply(QVariantMap* map, QVariantList fileMatches) {
  QVariantMap* repMap = new QVariantMap();
  repMap->insert(*destKey, map->value(*originKey).toString());
  repMap->insert(*originKey, *(dialog->myOriginID));
  repMap->insert(*hopLimitKey, (quint32) 10);
  repMap->insert(*searchReplyKey, map->value(*searchRequestKey).toString());
  repMap->insert(*matchIDsKey, dialog->getMetafileHashes(fileMatches));

  // After the metafile hashes have been obtained note that 'fileMatches' is
  // still filled with things like '/c/cs426/home/notes.txt'.  We should replace
  // all those entries with simply the filenames, like 'notes.txt'.
  repMap->insert(*matchNamesKey, stripPaths(fileMatches));

  QString dest_str = repMap->value(*destKey).toString();
  Destination* dest = routingTable->value(dest_str);
  sendMap(repMap, dest);
}

QList<QVariant> NetSocket::stripPaths(QList<QVariant> list) {
  QList<QVariant> newList;
  for (QVariant v : list) {
    newList.append(v.toString().split('/').last());
  }
  return newList;
}

void NetSocket::sendBlockRequest(const QString* dest, QString orig,
                                 quint32 hopLimit, QByteArray blockRequest) {
  requestMap = new QVariantMap();
  hashOfRequestedBlock = blockRequest;
  requestMap->insert(*destKey, *dest);
  requestMap->insert(*originKey, orig);
  requestMap->insert(*hopLimitKey, hopLimit);
  requestMap->insert(*blockRequestKey, blockRequest);
  if (routingTable->contains(*dest)) {
    requestDest = routingTable->value(*dest);
    requestingBlock = true;
    sendMap(requestMap, requestDest);

    brTimer = new QTimer(this);
    connect(brTimer, SIGNAL(timeout()), this, SLOT(sendMapBlockRequest()));
    brTimer->start(3000);
  } else {
    qDebug() << "Error. routing table did not contain: " << *dest;
  }
}

void NetSocket::sendMapBlockRequest() {
  if (requestingBlock) {
    sendMap(requestMap, requestDest);
  } else {
    brTimer->stop();
  }
}

void NetSocket::sendBlockReply(QVariantMap* map) {
  quint32 hopLimit = 10;
  map->insert(*hopLimitKey, hopLimit);
  QByteArray blockHash = map->value(*blockRequestKey).toByteArray();

  // Swap dest and origin.
  // Beware of trying to access old dest / origin values in the future.
  map->insert(*destKey, map->value(*originKey).toString());
  map->insert(*originKey, *(dialog->myOriginID));

  map->remove(*blockRequestKey);
  QByteArray data = dialog->findBlock(blockHash);
  QByteArray dataHash = QByteArray();
  dataHash.append(QCA::Hash("sha1").hash(data).toByteArray());

  map->insert(*dataKey, data);
  map->insert(*blockReplyKey, dataHash);

  const QString dest = map->value(*destKey).toString();
  if (routingTable->contains(dest)) {
    sendMap(map, routingTable->value(dest));
  }
}

void NetSocket::sendStatusMessage(Peer* peer) {
  // Construct and send the status message.
  QVariantMap* map = new QVariantMap();
  QVariantMap* wantMap = new QVariantMap();
  MessageList* myMessages = dialog->messages.load();
  for (MessageList::iterator it = myMessages->begin();
      it != myMessages->end(); ++it) {
    wantMap->insert(it->first, (quint32) it->second.size() + 1);
  }
  map->insert(*wantKey, *wantMap);
  sendMap(map, peer);
}

bool NetSocket::isRouteRumor(QVariantMap* map) {
  return (!map->contains(*chatTextKey) && map->contains(*originKey)
      && map->contains(*seqNoKey));
}

bool NetSocket::isRumorWithText(QVariantMap* map) {
  return (map->contains(*chatTextKey) && map->contains(*originKey)
      && map->contains(*seqNoKey));
}

bool NetSocket::isPrivRumor(QVariantMap* map) {
  return (map->size() == 4 && map->contains(*chatTextKey)
      && map->contains(*originKey) && map->contains(*destKey)
      && map->contains(*hopLimitKey));
}

bool NetSocket::isCryptoMsg(QVariantMap* map) {
  return map->contains(*cryptoKey) || map->contains("Crypto");
}

bool NetSocket::isBlockReply(QVariantMap* map) {
  return (map->size() == 5 && map->contains(*destKey)
      && map->contains(*originKey) && map->contains(*hopLimitKey)
      && map->contains(*blockReplyKey) && map->contains(*dataKey));
}

bool NetSocket::isBlockRequest(QVariantMap* map) {
  return (map->size() == 4 && map->contains(*destKey)
      && map->contains(*originKey) && map->contains(*hopLimitKey)
      && map->contains(*blockRequestKey));
}

bool NetSocket::isSearchRequest(QVariantMap* map) {
  return (map->size() == 3 && map->contains(*originKey)
      && map->contains(*searchRequestKey) && map->contains(*budgetKey));
}

bool NetSocket::isSearchReply(QVariantMap* map) {
  return map->size() == 6 && map->contains(*destKey)
      && map->contains(*originKey) && map->contains(*hopLimitKey)
      && map->contains(*searchReplyKey) && map->contains(*matchNamesKey)
      && map->contains(*matchIDsKey);
}

bool NetSocket::isStatusMessage(QVariantMap* map) {
  return (map->size() == 1 && map->contains(*wantKey));
}

bool NetSocket::isVoteHistory(QVariantMap* map) {
  return (map->size() == 2 && map->contains(*vhKey)
      && map->contains(*tagKey));
}

void NetSocket::handleStatusMessage(QVariantMap* map, Peer* peer, 
    quint16 port) {
  if (portWaitingFor == port && IPwaitingFor == peer->IP) {
    portWaitingFor = 0;
    IPwaitingFor = QHostAddress::Null;
  }

  // A status was received.  We're not currently waiting on any rumor.
  QVariantMap* oldRumorMessage = currentRumorMessage.load();
  currentRumorMessage = NULL;

  // Experimental line: Whenever CRM is set to NULL, try handling the outgoing
  // RQ again.
  handleOutgoingRQ();

  const QVariantMap wantMap = map->value(*wantKey).toMap();

  MessageList* myMessages = dialog->messages.load();
  bool theyNeed = false;
  bool iNeed = false;

  // Give them all the mesages they don't have, out of our shared origin IDs.
  for (QVariantMap::const_iterator it = wantMap.begin();
      it != wantMap.end(); ++it) {
    quint32 theirWant = it.value().toUInt();
    quint32 myWant;
    if (myMessages->count(it.key()) == 0) {
      myWant = 1;
    } else {
      myWant = myMessages->at(it.key()).size() + 1;
    }

    if (!iNeed && (myMessages->count(it.key()) == 0 || theirWant > myWant)) {
      iNeed = true;
      sendStatusMessage(peer);
    }
    if (myWant > theirWant && forwarding) {
      theyNeed = true;
      vector<QString> messages = myMessages->at(it.key());
      for (quint32 n = theirWant; n < myWant; ++n) {
        sendRumor(peer, messages.at(n - 1), it.key(), n);
      }
    }
  }

  // Iterate through all my messages. If I have origin IDs that they don't have,
  // send all those messages from those origin IDs to them.
  for (MessageList::iterator it = myMessages->begin();
      it != myMessages->end(); ++it) {
    vector<QString> messages = myMessages->at(it->first);
    if (!wantMap.contains(it->first)) {
      for (quint32 n = 0; n < messages.size(); ++n) {
        sendRumor(peer, messages.at(n), it->first, n + 1);
      }
    }
  }

  if (!iNeed && !theyNeed && rand() % 2 == 0 && oldRumorMessage != NULL) {
    incomingRQ.load()->push(oldRumorMessage);
    handleIncomingRQ();
  }
}

void NetSocket::updateVH(QStringList* vh) {
  for (QStringList::iterator i = vh->begin(); i != vh->end(); ++i) {
    QStringList l = (*i).split(",");
    addVote(l.at(0), l.at(1), l.at(2), l.at(3).toInt());
  }
}

void NetSocket::handleVoteHistory(QVariantMap* map, Peer* peer) {
  QStringList vh = map->value(*vhKey).toStringList();
  updateVH(&vh);
  int tag = map->value(*tagKey).toInt();
  if (tag == 1) {
    sendVH(peer, 2);  // Tag of 2 means that I don't want a vh back.
  }
}

void NetSocket::readMessage() {
  if (hasPendingDatagrams()) {
    QByteArray buf(pendingDatagramSize(), Qt::Uninitialized);
    QDataStream str(&buf, QIODevice::ReadOnly);
    QVariantMap *map = new QVariantMap();
    QHostAddress address;
    quint16 port;
    readDatagram(buf.data(), buf.size(), &address, &port);
    str >> *map;

    Peer* peer = findOrAddPeer(address, port);
    QString orig = map->value(*originKey).toString();
    
    // qDebug() << *map;
    if (isPrivRumor(map) || isCryptoMsg(map) || isBlockRequest(map) || isBlockReply(map) ||
        isSearchReply(map)) {
      handleForwardable(map, orig);
    } else if (isSearchRequest(map)
              && map->value(*originKey).toString() != *(dialog->myOriginID)) {
      handleIncomingSearchRequest(map);
    } else if (isRumorWithText(map) || isRouteRumor(map)) {
      handleIncomingRumorMsg(map, orig, address, port, peer);
    } else if (isVoteHistory(map)) {
      handleVoteHistory(map, peer);
    } else if (isStatusMessage(map)) {
      handleStatusMessage(map, peer, port);
    }
  }
}

int NetSocket::voted(QString voter, QString uploader, QString filename) {
  // returns 1 or 0 if voted.  (1 for yes vote, 0 for no vote.  But returns -1
  // if voter didn't vote on this file.)
  UploaderFileVote ufv = votingHistory->value(voter);
  if (ufv.count(uploader) == 0) {
    qDebug() << "voted: Nothing by this uploader.";
    return 0;
  } else {
    FileVote fv = ufv.value(uploader);
    if (fv.count(filename) == 0) {
      qDebug() << "voted: No filenames matching for this uploader.";
      return 0;
    } else {
      if (fv.value(filename) != 1 && fv.value(filename) != -1) {
        qDebug() << "Error: fv.value(filename) not +- 1.";
      }
      return fv.value(filename);
    }
  }
}

void addOverlappingFile(QMap<QString, QList<QString>>* S, QString uploader,
                        QString filename) {
  if (S->count(uploader) == 0) {
    QList<QString> list;
    list.append(filename);
    S->insert(uploader, list);
  } else {
    QList<QString> list = S->value(uploader);
    list.append(filename);
  }
}

double NetSocket::similarity(QString voter) {
  // Compile S, the set of overlapping files.  Maps UPLOADER to LIST of FILES
  QMap<QString, QList<QString>> S;
  int Ssize = 0;
  int a = 0;       // num I vote yes
  int b = 0;       // num he vote yes
  int posaggr = 0; // num both vote yes
  UploaderFileVote myUFV = votingHistory->value(*(dialog->myOriginID));
  UploaderFileVote hisUFV = votingHistory->value(voter);
  UploaderFileVote::iterator ufvi;
  for (ufvi = myUFV.begin(); ufvi != myUFV.end(); ufvi++) {
    QString uploader = ufvi.key();
    FileVote myFV = ufvi.value();
    if (hisUFV.count(uploader) != 0) {
      FileVote hisFV = hisUFV.value(uploader);
      FileVote::iterator fvi;
      for (fvi = myFV.begin(); fvi != myFV.end(); fvi++) {
        QString filename = fvi.key();
        if (hisFV.count(filename) != 0) {
          if (fvi.value() == 1) a++;
          if (hisFV.value(filename) == 1) b++;
          if (fvi.value() == 1 && hisFV.value(filename) == 1) posaggr++;
          Ssize++;
          addOverlappingFile(&S, uploader, filename);
        }
      }
    }
  }

  if (Ssize == 0 || a == Ssize || b == Ssize) return -2;
  double p = (double) posaggr / Ssize;
  double afrac = (double) a / Ssize; 
  double bfrac = (double) b / Ssize;
  double thetaNum = p - afrac * bfrac;
  double thetaDen = sqrt(afrac * (1 - afrac) * bfrac * (1 - bfrac));
  double theta = thetaNum / thetaDen;
  if (thetaDen == 0) {
    return -2;
  }
  if (theta > 1 || theta < -1) {
    qDebug() << "Invalid value for theta: " << theta;
  }
  return theta;
}

double NetSocket::calculateScore(QString uploader, QString filename) {
  double num = 0;
  double den = 0;

  VotingHistory::iterator vhi;
  for (vhi = votingHistory->begin(); vhi != votingHistory->end(); vhi++) {
    QString voter = vhi.key();
    // 1 (upvote) or -1 (downvote) if voted, 0 if not voted
    int vote = voted(voter, uploader, filename);
    if (voter != *(dialog->myOriginID) && vote != 0) {
      double theta = similarity(voter);
      if (theta != -2) {  // theta would be -2 if undefined somehow
        den += abs(theta);
        qDebug() << den;
        num += vote * theta;
        qDebug() << num;
      }
    }
  }

  if (den == 0) return -2;  // indicates that there isn't enough vote data
  return num / den;
}

// By this point I already know it's for me.
void NetSocket::handleSearchReply(QVariantMap* map) {
  if (map->value(*searchReplyKey).toString() == searchText) {
    QVariantList matchNames = map->value(*matchNamesKey).toList();
    for (int i = 0; i < matchNames.size(); ++i) {
      QString fileName = matchNames.at(i).toString();

      // Don't add the barrier-to-entry files!
      QString regexStr = generateBTERegexString();
      QRegExp regex(regexStr);
      if (unlocked && regex.exactMatch(fileName)) {
        return;
      }

      if (resultMap->count(fileName) == 0) {
        numMatches++;
        ResultData data;
        data.hash = getByteArraySubset(i,
            map->value(*matchIDsKey).toByteArray());
        data.uploaderDest = map->value(*originKey).toString();
        resultMap->insert(make_pair(fileName, data));
        QString fileNameScore;
        fileNameScore.append(fileName);
        double score = calculateScore(data.uploaderDest, fileName);
        if (score != -2) {
          fileNameScore.append(" (");
          fileNameScore.append(QString::number(score));
          fileNameScore.append(")");
        } else {
          fileNameScore.append(" (No score available).");
        }
        new QListWidgetItem(fileNameScore, dialog->searchResults);  // Vote score in parens
      }
    }
  }
}

QByteArray NetSocket::getByteArraySubset(int i, QByteArray b) {
  QByteArray c;
  for (int j = 0; j < 20; ++j) {
    c.append(b.at(20 * i + j));
  }
  return c;
}

void NetSocket::handleIncomingSearchRequest(QVariantMap* map) {
  QVariantList fileMatches =
      findQueryMatches(map->value(*searchRequestKey).toString());


  if (!fileMatches.empty()) {
    sendSearchReply(map, fileMatches);
  }

  if (map->value(*budgetKey).toUInt() > 0) {
    distributeSearchQuery(map);
  }
}

void NetSocket::handleForwardable(QVariantMap* map, QString orig) {
  QString destOrigin = map->value(*destKey).toString();
  
  if (destOrigin.compare(*(dialog->myOriginID)) != 0) {
    // Private message / block request not for me.
    if (forwarding) {
      quint32 hopsLeft = map->value(*hopLimitKey).toUInt() - 1;
      if (hopsLeft > 0) {
        map->insert(*hopLimitKey, hopsLeft);
        if (routingTable->contains(destOrigin)) {
          sendMap(map, routingTable->value(destOrigin));
        }
      }
    }
  } else if (isPrivRumor(map) || isCryptoMsg(map)) {
      dialog->openPrivateMsgWindow(orig);

      
      // If this message is delivering cryptographic keys.
      if (isCryptoMsg(map)){
        QPair<QString, QString> pair = qMakePair(map->value("PublicKey").toString(), QString(map->value("N").toString()));
        // Store the public key from peer at orig.
        dialog->cryptoKeys->insert(orig, pair);

        // qDebug() << "Public Key: " << map->value("PublicKey").toString() << "\n\n\nN: " << map->value("N").toString();
      } else {
        QString encrypted_msg = map->value(*chatTextKey).toString();
        string priv_key = dialog->priv_key;
        string n = dialog->n;
        string decrypted_msg = rsa_decrypt(encrypted_msg.toUtf8().constData(), priv_key, n);

        dialog->privMsgs->value(orig)->textview->append(decrypted_msg.c_str());
      }


  } else if (isBlockRequest(map)) {
    sendBlockReply(map);
  } else if (isBlockReply(map)) {
    handleBlockReply(map);
  } else if (isSearchReply(map)) {
    handleSearchReply(map);
  }
  return;
}

// Will be overwriting budget field. Don't try to access old budget field
// value in the future!
void NetSocket::distributeSearchQuery(QVariantMap* map) {
  quint32 budget = map->value(*budgetKey).toUInt();
  quint32 numNeighbors = peers.size();
  if (numNeighbors > budget) {
    QList<Peer*> sendTo;
    for (quint32 i = (quint32) 0; i < budget; ++i) {
      Peer* poss = getRandomPeer();
      if (!sendTo.contains(poss)) {
        sendTo.append(poss);
      }
    }
    map->insert(*budgetKey, (quint32) 1);
    for (Peer* peer : sendTo) {
      sendMap(map, peer);
    }
  } else {
    int numExtra = budget % numNeighbors;
    int numNormal = budget - numExtra;
    QList<Peer*> classAPeer;
    QList<Peer*> classBPeer;
    for (int i = 0; i < numExtra; ++i) {
      Peer* poss = getRandomPeer();
      if (!classAPeer.contains(poss)) {
        classAPeer.append(poss);
      }
    }
    for (int i = 0; i < numNormal; ++i) {
      Peer* poss = getRandomPeer();
      if (!classAPeer.contains(poss) && !classBPeer.contains(poss)) {
        classBPeer.append(poss);
      }  
    }

    map->insert(*budgetKey, (quint32) (budget / numNeighbors + 1));
    for (Peer* peer : classAPeer) {
      sendMap(map, peer);
    }
    map->insert(*budgetKey, (quint32) (budget / numNeighbors));
    for (Peer* peer : classBPeer) {
      sendMap(map, peer);
    }
  }
}

void NetSocket::handleIncomingRumorMsg(QVariantMap* map, QString orig,
    QHostAddress address, quint16 port, Peer* peer) {
  quint32 seqno = map->value(*seqNoKey).toUInt();

  // Add/update the lastIP / lastPort node in my peers list.
  // Casting is required for lastIP, because it was stored as a quint32.
  if (map->contains(*lastIPKey) && map->contains(*lastPortKey)) {
    QHostAddress* lastIP = new QHostAddress(map->value(*lastIPKey).toUInt());
    quint16 lastPort = map->value(*lastPortKey).toInt();
    if (*lastIP != QHostAddress::LocalHost || lastPort != myPort) {
      findOrAddPeer(*lastIP, lastPort);
    }
  }

  // Add/update this node in my routing table.
  if (orig.compare(*(dialog->myOriginID)) != 0) {
    if (!routingTable->contains(orig)) {
      new QListWidgetItem(orig, dialog->peerOrigins);
      Destination* dest = new Destination();
      updateDest(dest, address, port, seqno);
      routingTable->insert(orig, dest);
    } else {
      // I do have an entry for this Origin; update the entry if the
      // sequence number is higher, or if the sequence no's are the same AND
      // the route is direct.
      Destination* dest = routingTable->value(orig);
      if ((seqno > dest->seqno)
          || (seqno == dest->seqno && !map->contains(*lastPortKey)
              && !map->contains(*lastIPKey))) {
        updateDest(dest, address, port, seqno);
      }
    }
  }

  map->insert(*lastIPKey, address.toIPv4Address());
  map->insert(*lastPortKey, port);

  if (isNewRumor(map)) {
    incomingRQ.load()->push(map);
    handleIncomingRQ();
  }

  sendStatusMessage(peer);
}

void NetSocket::addVote(QString voter, QString uploader, QString filename,
                        int res) {
  // res = 1 if upvote, 0 if downvote. For simplicity we'll convert res to -1
  // if its 0 to match the rest of the system.
  if (votingHistory->count(voter) != 0) {
    UploaderFileVote ufv = votingHistory->value(voter);
    if (ufv.count(uploader) != 0) {
      FileVote fv = ufv.value(uploader);
      fv.insert(filename, (res == 1 ? 1 : -1));
      ufv.insert(uploader, fv);
    } else {
      FileVote fv;
      fv.insert(filename, (res == 1 ? 1 : -1));
      ufv.insert(uploader, fv);
    }
    votingHistory->insert(voter, ufv);
  } else {
    UploaderFileVote ufv;
    FileVote fv;
    fv.insert(filename, (res == 1 ? 1 : -1));
    ufv.insert(uploader, fv);
    votingHistory->insert(voter, ufv);
  }
}

QStringList* NetSocket::convertToStringList(VotingHistory* vh) {
  QStringList* l = new QStringList();
  VotingHistory::iterator vhi;
  for (vhi = vh->begin(); vhi != vh->end(); vhi++) {
    QString voter = vhi.key();
    UploaderFileVote ufv = vhi.value();
    UploaderFileVote::iterator ufvi;
    for (ufvi = ufv.begin(); ufvi != ufv.end(); ufvi++) {
      QString uploader = ufvi.key();
      FileVote fv = ufvi.value();
      FileVote::iterator fvi;
      for (fvi = fv.begin(); fvi != fv.end(); fvi++) {
        QString file = fvi.key();
        QString vote = QString::number(fvi.value());
        QString elt;
        elt += voter + "," + uploader + "," + file + "," + vote;
        l->append(elt);
      }
    }
  }
  return l;
}

void NetSocket::sendVH(Peer* peer, int tag) {
  QVariantMap* map = new QVariantMap();
  map->insert(*tagKey, tag);  // 1 means I want reply. 2 means no reply.
  QStringList* sl = convertToStringList(votingHistory);
  qDebug() << "Voting history is: " << *sl;
  map->insert(*vhKey, *sl);
  sendMap(map, peer);
}

void NetSocket::tabulateVote() {
  addVote(*(dialog->myOriginID), curUploader, nameOfRequestedFile,
          curvd->result());

  int tag = 1;
  for (Peer* peer : peers) {
    sendVH(peer, tag);
  }
}

void NetSocket::handleBlockReply(QVariantMap* map) {
  // Check if hash of "Data" value matches the "BlockReply" value.
  QByteArray data = map->value(*dataKey).toByteArray();
  QByteArray blockReply = map->value(*blockReplyKey).toByteArray();
  QString dataHash = QCA::Hash("sha1").hash(data).toByteArray();
  // New dest is old origin.
  QString destOrigin = map->value(*originKey).toString();

  if (hashOfRequestedBlock == dataHash
      && dataHash == blockReply) {
    requestingBlock = false;
    if (requestingMetafile && !requestingDataBlock) {
      requestingMetafile = false;
      requestingDataBlock = true;
      blocksRemaining = data.size() / 20;
      if (data.size() % 20 != 0) {
        qDebug() << "Got metafile with # of Chars not divisible by 20.";
      }
      QByteArray firstBlock = data.left(20);
      metafileOfRequestedBlock = data;
      metafileOfRequestedBlock.remove(0, 20);
      sendBlockRequest(&destOrigin, *(dialog->myOriginID), (quint32) 10,
                       firstBlock);
      fileAccumulating = QByteArray();
    } else if (!requestingMetafile && requestingDataBlock) {
      fileAccumulating.append(data);
      blocksRemaining--;
      if (blocksRemaining > 0) {
        if (data.size() != 8192) {
          qDebug() << "Received nonfinal file block of size != 8192";
        }
        sendBlockRequest(&destOrigin, *(dialog->myOriginID),
                         (quint32) 10,
                         metafileOfRequestedBlock.left(20));
        metafileOfRequestedBlock.remove(0, 20);
      } else if (blocksRemaining == 0) {
        requestingDataBlock = false;
        QFile file(nameOfRequestedFile);
        file.open(QIODevice::WriteOnly);
        file.write(fileAccumulating);
        file.close();

        downloadedFiles->insert(nameOfRequestedFile);

        dialog->searchResults->setEnabled(true);

        if (unlocked) {
          VoteDialog* vd = new VoteDialog();
          this->curvd = vd;
          this->curUploader = destOrigin;
          connect(vd, SIGNAL(finished(int)), this, SLOT(tabulateVote()));
          vd->show();
        } else {
          dialog->addFile(nameOfRequestedFile);
        }
      }
    } else {
      qDebug() << "Not requesting metafile or data block (or requesting both).";
    }
  }
}

QVariantList NetSocket::findQueryMatches(QString query) {
  QRegExp regex(query);
  FileMap* fileMap = dialog->fileMap;
  QVariantList response = QVariantList();
  for (FileMap::iterator it = fileMap->begin(); it != fileMap->end(); ++it) {
    QString str = it->first.split('/').last();
    if (regex.exactMatch(str)) {
      response.append(it->first);
    }
  }
  return response;
}

void NetSocket::updateDest(Destination* dest, QHostAddress addr, quint16 port,
    quint32 seqno) {
  dest->IP = addr;
  dest->port = port;
  dest->seqno = seqno;
}

bool NetSocket::isNewRumor(QVariantMap* map) {
  QString orig = map->value(*originKey).toString();
  quint32 seqno = map->value(*seqNoKey).toUInt();
  MessageList* myMessages = dialog->messages.load();
  if (myMessages->count(orig) == 0) {
    return true;
  }
  return seqno > myMessages->at(orig).size();
}

bool NetSocket::isNextRumor(QVariantMap* map) {
  QString orig = map->value(*originKey).toString();
  quint32 seqno = map->value(*seqNoKey).toUInt();
  MessageList* myMessages = dialog->messages.load();
  if (myMessages->count(orig) == 0) {
    return seqno == 1;
  }
  quint32 myNum = myMessages->at(orig).size();
  return (seqno == myNum + 1);
}

void NetSocket::handleIncomingRQ() {
  while (incomingRQ.load()->size() != 0) {
    QVariantMap* map = incomingRQ.load()->front();
    incomingRQ.load()->pop();

    // Only add it if it's the next one I need, and rumormonger it. If it's
    // not the next one I need, it IS safe to discard, because a status
    // message was sent when this rumor was received. So I should be (later)
    // getting the missing messages from at least the node that sent me this
    // rumor.
    if (isNextRumor(map)) {
      if (isRumorWithText(map)) {
        dialog->displayMsg(map->value(*chatTextKey).toString(),
                           map->value(*originKey).toString());
      }
      dialog->addMsg(map);
      outgoingRQ.load()->push(map);
      handleOutgoingRQ();
    }
  }
}

void NetSocket::handleOutgoingRQ() {
  while (outgoingRQ.load()->size() != 0 && currentRumorMessage == NULL) {
    QVariantMap* map = outgoingRQ.load()->front();
    outgoingRQ.load()->pop();

    if (map->value(*originKey) == *(dialog->myOriginID)
        || forwarding || !map->contains(*chatTextKey)) {
      currentRumorMessage = map;
      rumor(map);
    }
  }
}

void NetSocket::rumor(QVariantMap* map) {
  if (!map->contains(*chatTextKey)) {
    // If it's a rumor route message, send it to all peers.
    for (Peer* peer : peers) {
      sendMap(map, peer);
    }
  } else {
    Peer* peer = getRandomPeer();
    sendMap(map, peer);

    portWaitingFor = peer->port;
    IPwaitingFor = peer->IP;

    QTimer *timer = new QTimer(this);
    timer->setSingleShot(true);
    connect(timer, SIGNAL(timeout()), this, SLOT(rumorTimeout()));
    timer->start(1000);
  }
}

void NetSocket::rumorTimeout() {
  if (portWaitingFor != 0) {
    // Timed out waiting for a status message.
    portWaitingFor = 0;
    IPwaitingFor = QHostAddress::Null;
    QVariantMap* map = currentRumorMessage;

    if (map != NULL) {
      rumor(map);
    }  
  }
}

int main(int argc, char **argv) {
  // Seed randomization.
  srand(time(0));

  // Initialize Qt toolkit
  QApplication app(argc,argv);

  QCA::Initializer qcainit;

  QStringList args = QCoreApplication::arguments();

  // Create a UDP network socket
  NetSocket* sock = new NetSocket();

  // Create a UDP network socket
  NetSocket* sock = new NetSocket(QCoreApplication::arguments());
  if (!sock->bind())
    exit(1);

  // Create an initial chat dialog window
  ChatDialog dialog(sock);
  sock->dialog = &dialog;

  // Parse the command line arguments:
  // - Check if this is a "-no-forward" node to prevent message forwarding
  // - Check if this is a "-seed" node (i.e. first node in the network)
  // - Add in the peers given in the command line.
  bool seed = false;
  for (int i = 1; i < args.size(); ++i) {
    QString s = args.at(i);
    if (s.at(0) == '-') {
      if (s == "-noforward") {
        qDebug() << "no forwarding detected.";
        sock->forwarding = false;
      } else if (s == "-seed") {
        qDebug() << "Generating barrier-to-entry seed files...";
        seed = true;
        dialog.btnUnlock->setVisible(false);
        for (int j = 0; j < BTE_COUNT; j++) {
          QByteArray arr(BTE_SIZE, '\0');
          for (int k = 0; k < BTE_SIZE; k++) {
            arr[k] = qrand() % 256;
          }
          QString fileName = generateBTEFileName(j);
          QFile file(fileName);
          file.open(QIODevice::WriteOnly);
          file.write(arr);
          file.close();
          dialog.addFile(fileName);
        }
      }
    } else {
      qDebug() << "Adding peer:" << args.at(i);
      sock->addPeer(args.at(i), 0);    // add these peers synchronously
    }
  }

  // Send out the initial rumor
  sock->routeRumor();

  dialog.show();

  // If you're not the seed, you have to try and get the barrier-to-entry files
  // from your peers before you're allowed to use Peerster
  if (!seed) {
    // Disable usage of Peerster
    dialog.peerline->setEnabled(false);
    dialog.peerOrigins->setEnabled(false);
    dialog.searchline->setEnabled(false);
    dialog.m_button->setEnabled(false);
    dialog.textline->setEnabled(false);
    dialog.textview->setEnabled(false);

    // Get all the seed files
    qDebug() << "Waiting to receive all seed files...";
    QString query = generateBTERegexString();
    QListWidgetItem item(query);
    sock->handleSearchRequest(query);
    qDebug() << "Sent requests all seed files!";
  }
  dialog.show();
  sock->routeRumor();

  // Enter the Qt main loop; everything else is event driven
  return app.exec();
}

